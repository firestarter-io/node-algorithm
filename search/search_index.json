{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Firestarter.io - Algorithm Documentation About These documents give a high-level description of the core fire-prediction algorithm that lies at the heart of FireStarter. These docs do not provide exhaustive api-style documentation for every property and method available throughout the FireStarter codebase. Philosophy FireStarer.io's central algorithm takes a cellular automata approach to modeling wildfire phenomena. A geographic location under examination is abstracted into a grid, and environmental factors at each point in the grid can be extracted from GIS raster data (DEM, groundcover, etc.). Calculations are made based off of the data at each point to determine whether or not fire will spread into that point, what affect that may have on human development, and vice versa. Because the computational burden of such an algorithm is high, it is best to run the algorithm on machines that are optimized for running large numbers of calculations in as fast a time as possible. For that reason, the algorithm is couched in a server-side application, which can be run using compute-optimized cloud resources, offloading the computational burden to faster machines.","title":"About"},{"location":"#firestarterio-algorithm-documentation","text":"","title":"Firestarter.io - Algorithm Documentation"},{"location":"#about","text":"These documents give a high-level description of the core fire-prediction algorithm that lies at the heart of FireStarter. These docs do not provide exhaustive api-style documentation for every property and method available throughout the FireStarter codebase.","title":"About"},{"location":"#philosophy","text":"FireStarer.io's central algorithm takes a cellular automata approach to modeling wildfire phenomena. A geographic location under examination is abstracted into a grid, and environmental factors at each point in the grid can be extracted from GIS raster data (DEM, groundcover, etc.). Calculations are made based off of the data at each point to determine whether or not fire will spread into that point, what affect that may have on human development, and vice versa. Because the computational burden of such an algorithm is high, it is best to run the algorithm on machines that are optimized for running large numbers of calculations in as fast a time as possible. For that reason, the algorithm is couched in a server-side application, which can be run using compute-optimized cloud resources, offloading the computational burden to faster machines.","title":"Philosophy"},{"location":"algorithm/burnmatrix/","text":"BurnMatrix Creation A BurnMatrix belongs to an Extent . It is a mathematical abstraction representing all the pixels in an extent. A BurnExtent is a MathJS SparseMatrix whose size is the same as the size of the Extent . For example, an Extent that is 3 tiles wide by 2 tiles tall, with a tilesize of 256 pixels, will have a BurnMatrix of size [256 * 3, 256 * 2] . A BurnMatrix is created and associated with an extent when a new Extent is created. The Extent is also available from the BurnMatrix - there is always a 1 to 1 relationship, meaning Extents won't share a BurnMatrix , and vice versa. A BurnMatrix is dynamic , meaning its state is constantly changing over the life of the algorithm. Looking at a BurnMatrix at one point in time tells you nothing about its state at another point in time. However, a snapshot of the BurnMatrix is taken at every Timestep , so the evolution of the BurnMatrix can be seen by following the trail of its snapshots through an array of Timesteps . Coordinates A Mathjs matrix is a wrapped around a javascript array. A 2 dimensional matrix is an array of inner arrays: const matrix = math.zeros(2, 3) [ [0, 0, 0], [0, 0, 0] ]; Note that the coordinates for all matrix operations are in [y, x] format . A BurnMatrix redefines any necessary matrix methods to use [x, y] coordinates for consistency with canvas data methods. For example, CanvasRenderingContext2D.getImageData() takes coordinates in [x, y] order. This is the reason that certain BurnMatrix and Extent methods use [y, x] coordinates.","title":"BurnMatrix"},{"location":"algorithm/burnmatrix/#burnmatrix","text":"","title":"BurnMatrix"},{"location":"algorithm/burnmatrix/#creation","text":"A BurnMatrix belongs to an Extent . It is a mathematical abstraction representing all the pixels in an extent. A BurnExtent is a MathJS SparseMatrix whose size is the same as the size of the Extent . For example, an Extent that is 3 tiles wide by 2 tiles tall, with a tilesize of 256 pixels, will have a BurnMatrix of size [256 * 3, 256 * 2] . A BurnMatrix is created and associated with an extent when a new Extent is created. The Extent is also available from the BurnMatrix - there is always a 1 to 1 relationship, meaning Extents won't share a BurnMatrix , and vice versa. A BurnMatrix is dynamic , meaning its state is constantly changing over the life of the algorithm. Looking at a BurnMatrix at one point in time tells you nothing about its state at another point in time. However, a snapshot of the BurnMatrix is taken at every Timestep , so the evolution of the BurnMatrix can be seen by following the trail of its snapshots through an array of Timesteps .","title":"Creation"},{"location":"algorithm/burnmatrix/#coordinates","text":"A Mathjs matrix is a wrapped around a javascript array. A 2 dimensional matrix is an array of inner arrays: const matrix = math.zeros(2, 3) [ [0, 0, 0], [0, 0, 0] ]; Note that the coordinates for all matrix operations are in [y, x] format . A BurnMatrix redefines any necessary matrix methods to use [x, y] coordinates for consistency with canvas data methods. For example, CanvasRenderingContext2D.getImageData() takes coordinates in [x, y] order. This is the reason that certain BurnMatrix and Extent methods use [y, x] coordinates.","title":"Coordinates"},{"location":"algorithm/campaign/","text":"Campaign Creation A Campaign represents a complete simulation in Firestarter. Given a set of user inputs, a new Campaign is created and its timeline begins running. A Campaign contains the following main properties Campaign.extents - Array of Extent objects Campaign.eventQueue - The event queue of the campaign Campaign.timesteps - Array of Timestep objects A Campaign object acts as the coordinator and center of all activities required to run a simulation Flow","title":"Campaign"},{"location":"algorithm/campaign/#campaign","text":"","title":"Campaign"},{"location":"algorithm/campaign/#creation","text":"A Campaign represents a complete simulation in Firestarter. Given a set of user inputs, a new Campaign is created and its timeline begins running. A Campaign contains the following main properties Campaign.extents - Array of Extent objects Campaign.eventQueue - The event queue of the campaign Campaign.timesteps - Array of Timestep objects A Campaign object acts as the coordinator and center of all activities required to run a simulation","title":"Creation"},{"location":"algorithm/campaign/#flow","text":"","title":"Flow"},{"location":"algorithm/data/","text":"Data This section discusses data specific to the fire prediction algorithm (as opposed to Firestarter's app database which holds data about user accounts, campaigns, etc). Data Types Firestarter requires a myriad of GIS data, readily available via web sources for the areas where simulations are being run. The subject content of data can generally be divided into two classes: environmental data, and human-oriented data. Here are a few examples of each: Environmental Data Types Topography (elevation, slope, aspect) Ground Cover Weather (wind, temperature, humidity) Human Oriented Data Real estate data Fire supression capabiity Census bureau data How data is retrieved depends on the type of data and available sources. Data must be available for any given point on the map in a given map extent. For a given point, different data types will be available in different formats, generally falling into one of the two following types: Scalar : A singular numerical value. For example, elevation is numerical value in meters Vector : A value with magnitude and direction. For example, wind has both speed and direction, or topography has both slope (magnitued) and aspet (direction)","title":"Data"},{"location":"algorithm/data/#data","text":"This section discusses data specific to the fire prediction algorithm (as opposed to Firestarter's app database which holds data about user accounts, campaigns, etc).","title":"Data"},{"location":"algorithm/data/#data-types","text":"Firestarter requires a myriad of GIS data, readily available via web sources for the areas where simulations are being run. The subject content of data can generally be divided into two classes: environmental data, and human-oriented data. Here are a few examples of each: Environmental Data Types Topography (elevation, slope, aspect) Ground Cover Weather (wind, temperature, humidity) Human Oriented Data Real estate data Fire supression capabiity Census bureau data How data is retrieved depends on the type of data and available sources. Data must be available for any given point on the map in a given map extent. For a given point, different data types will be available in different formats, generally falling into one of the two following types: Scalar : A singular numerical value. For example, elevation is numerical value in meters Vector : A value with magnitude and direction. For example, wind has both speed and direction, or topography has both slope (magnitued) and aspet (direction)","title":"Data Types"},{"location":"algorithm/notes/","text":"General notes to self and TODOs Optimizations Notes on potential optimizations to implement. Consider using ndarray Currently a BurnMatrix is based on a MathJS SparseMatrix. Another option is the javascript implementation of an ndarray , which may or may not be faster for reading and writing to a BurnMatrix Bypass resample function on initial return Currently, TimeSteps are calculated and added to the Campaign.timesteps array. They are not resampled until the Campaign is ready to be sent to the front end. The resample function can be expensive on the CPU. However, for initial calculations, it can be avoided altogether. Within the iteration of Timesteps , Timestep.snapshot s can be added to a Campaign.snapshots array based on whether or not they satisfy the same constraints used when using resample , i.e., only adding a snapshot if timestep.time <= latestSampleTime just after adding the Timestep to Campaign.timesteps . The Campaign will always need to keep track of all Timestep s, as if a user wants to view the Campaign with a different timescale. For example, if a user initially wants to view a Campaign with a timescale of 1 hour, we can push Timestep.snapshot s to the Campaign.snapshots array every hour upon initial calculation. If they then want to view the same Campaign with a timescale of 1 day, we can then use the resample function against Campaign.timesteps to return that sampling.","title":"Notes"},{"location":"algorithm/notes/#optimizations","text":"Notes on potential optimizations to implement.","title":"Optimizations"},{"location":"algorithm/notes/#consider-using-ndarray","text":"Currently a BurnMatrix is based on a MathJS SparseMatrix. Another option is the javascript implementation of an ndarray , which may or may not be faster for reading and writing to a BurnMatrix","title":"Consider using ndarray"},{"location":"algorithm/notes/#bypass-resample-function-on-initial-return","text":"Currently, TimeSteps are calculated and added to the Campaign.timesteps array. They are not resampled until the Campaign is ready to be sent to the front end. The resample function can be expensive on the CPU. However, for initial calculations, it can be avoided altogether. Within the iteration of Timesteps , Timestep.snapshot s can be added to a Campaign.snapshots array based on whether or not they satisfy the same constraints used when using resample , i.e., only adding a snapshot if timestep.time <= latestSampleTime just after adding the Timestep to Campaign.timesteps . The Campaign will always need to keep track of all Timestep s, as if a user wants to view the Campaign with a different timescale. For example, if a user initially wants to view a Campaign with a timescale of 1 hour, we can push Timestep.snapshot s to the Campaign.snapshots array every hour upon initial calculation. If they then want to view the same Campaign with a timescale of 1 day, we can then use the resample function against Campaign.timesteps to return that sampling.","title":"Bypass resample function on initial return"},{"location":"algorithm/overview/","text":"Overview","title":"Overview"},{"location":"algorithm/overview/#overview","text":"","title":"Overview"},{"location":"algorithm/cell/cell/","text":"Cell A Cell represents a single pixel within a BurnMatrix . At its core, it is an abstraction layer for interacting with and making changes to the BurnMatrix . A Cell is tied to a particular Extent , and it has methods which enable it to access the Extent 's data at its own position within that Extent . It is also connected to the Extent 's BurnMatrix , and is able to get and set burn values at the Cell 's position in its BurnMatrix . FireStarter's stochastic model relies on a Cell 's ability to access its neighboring positions within its BurnMatrix . To that end, a Cell has the neighbors() method, which spawns 8 NeighborCell s, forming a Moore Neighborhood . NeighborCell When a Cell calls its neighbors() method, an array of 8 NeighborCells is returned, representing the 8 pixels that surround the original cell. Each NeighborCell has additional properties used to calculate the probability of whether or not fire will spread from a burning Cell to that NeighborCell . For example, the terrain slope from the origin cell to each neighbor is produced when calling NeighborCell.getSlopeFromOriginCell . Similarly the wind component in the direction of that NeighborCell is available by calling `NeighborCell.getWindComponent . In this way, the burn status of each pixel in a BurnMatrix is determined by each Neighborcell . A Campaign always begins with a TimeStep in which a single Cell being set to burning . In the following TimeStep , the burn status of each NeighborCell is determined, and all burning Cell s are kept track of by the BurnMatrix . In the proceeding TimeStep s, all burning cells are iterated over, each burning Cell spawns its NeighborCells , whose burn statuses are determined and recorded, and so forth.","title":"Cell"},{"location":"algorithm/cell/cell/#cell","text":"A Cell represents a single pixel within a BurnMatrix . At its core, it is an abstraction layer for interacting with and making changes to the BurnMatrix . A Cell is tied to a particular Extent , and it has methods which enable it to access the Extent 's data at its own position within that Extent . It is also connected to the Extent 's BurnMatrix , and is able to get and set burn values at the Cell 's position in its BurnMatrix . FireStarter's stochastic model relies on a Cell 's ability to access its neighboring positions within its BurnMatrix . To that end, a Cell has the neighbors() method, which spawns 8 NeighborCell s, forming a Moore Neighborhood .","title":"Cell"},{"location":"algorithm/cell/cell/#neighborcell","text":"When a Cell calls its neighbors() method, an array of 8 NeighborCells is returned, representing the 8 pixels that surround the original cell. Each NeighborCell has additional properties used to calculate the probability of whether or not fire will spread from a burning Cell to that NeighborCell . For example, the terrain slope from the origin cell to each neighbor is produced when calling NeighborCell.getSlopeFromOriginCell . Similarly the wind component in the direction of that NeighborCell is available by calling `NeighborCell.getWindComponent . In this way, the burn status of each pixel in a BurnMatrix is determined by each Neighborcell . A Campaign always begins with a TimeStep in which a single Cell being set to burning . In the following TimeStep , the burn status of each NeighborCell is determined, and all burning Cell s are kept track of by the BurnMatrix . In the proceeding TimeStep s, all burning cells are iterated over, each burning Cell spawns its NeighborCells , whose burn statuses are determined and recorded, and so forth.","title":"NeighborCell"},{"location":"algorithm/extent/extent/","text":"Extent Creation An Extent represents a map extent. It is created from a L.LatLngBounds : const extent = new Extent (( bounds : L.LatLngBounds )); A new Extent takes in a bounds object, and refits those bounds to the bounds of the tiles that fit inside it from a standard Web Mercator Tile Layer: On extent creation, the tiles that fit within that extent are listed using xyz-affair : The extent's bounds are set as the bounds of the tiles that fit in the L.LatLngBounds fed to new Extent : Data fetching Once created, extent.fetchData() can be called, which will fetch all data sources for the extent. Growing an Extent In an effort to download data on a \"need-to-have\" basis, an Extent starts with a default size. In each TimeStep , the algorithm assigns Cell s within an Extent 's BurnMatrix to have non-zero burn values. At the time of that assignment, the distance of the Cell from the edges of its Extent is checked, and if that distance falls below the config's threshold, the Extent expands . Depending on which edge the Cell is closest to, Extent will call expandUp , expandDown , expandRight , or expandLeft . These methods will expand the Extent 's bounds and fetch all data tiles for the newly expanded parts of the Extent . expandUp and expandLeft will also reset the origin of the index and reset all the positions of the Cell s associated with the Extent . When an Extent grows by calling any of the above methods, it must be checked against all other Extent s in the Campaign for potential overlap.","title":"Extent"},{"location":"algorithm/extent/extent/#extent","text":"","title":"Extent"},{"location":"algorithm/extent/extent/#creation","text":"An Extent represents a map extent. It is created from a L.LatLngBounds : const extent = new Extent (( bounds : L.LatLngBounds )); A new Extent takes in a bounds object, and refits those bounds to the bounds of the tiles that fit inside it from a standard Web Mercator Tile Layer: On extent creation, the tiles that fit within that extent are listed using xyz-affair : The extent's bounds are set as the bounds of the tiles that fit in the L.LatLngBounds fed to new Extent :","title":"Creation"},{"location":"algorithm/extent/extent/#data-fetching","text":"Once created, extent.fetchData() can be called, which will fetch all data sources for the extent.","title":"Data fetching"},{"location":"algorithm/extent/extent/#growing-an-extent","text":"In an effort to download data on a \"need-to-have\" basis, an Extent starts with a default size. In each TimeStep , the algorithm assigns Cell s within an Extent 's BurnMatrix to have non-zero burn values. At the time of that assignment, the distance of the Cell from the edges of its Extent is checked, and if that distance falls below the config's threshold, the Extent expands . Depending on which edge the Cell is closest to, Extent will call expandUp , expandDown , expandRight , or expandLeft . These methods will expand the Extent 's bounds and fetch all data tiles for the newly expanded parts of the Extent . expandUp and expandLeft will also reset the origin of the index and reset all the positions of the Cell s associated with the Extent . When an Extent grows by calling any of the above methods, it must be checked against all other Extent s in the Campaign for potential overlap.","title":"Growing an Extent"},{"location":"algorithm/queue/queue/","text":"The PriorityQueue class in a TypeScript implementation of the priority queue data structure . Every campaign will have an eventQueue property, which is an instance of a PriorityQueue . Events The event queue is composed of EventQueueItem s. Each EventQueueItem provides information about some future event. An EventQueueItem takes this shape: interface EventQueueItem { time : number ; setToBurning ?: { [ key : string ] : Cell ; }; setToBurnedOut ?: { [ key : string ] : Cell ; }; } Detailed information can be found in the codebase for each entry. Event creation The events in the event queue have an asymetrical, one-to-one relationship with TimeStep s. When a Campaign initializes, an initlal event is pushed into the queue, and then a first TimeStep is initialized. Within the constructor of a TimeStep , it looks for the first event in the queue, and if it finds one, it performs its function based on the next queue event. For every event in the queue, a TimeStep will be created. In turn, a TimeStep may spawn more events to be added to the queue. A TimeStep may spawn multiple events to be added, or none at all. An event in the queue, noted by e above, fuels the creation of a TimeStep , which in turn spawns more events to be added to the queue. TimeStep \u2192 Queue \u2192 TimeStep When a TimeStep grabs the next item out of the queue, that item is removed from the queue (though for debugging purposes, it is moved to PriorityQueue.history ). A TimeStep always ends with a new one being created. The next TimeStep is always processing the next event in the queue, if there is one. And because a TimeStep may spawn new queue events (especially in the first portion of a simulation), the simulation runs in a continuous fashion. TimeSteps spawn more events, which provide the information required in the next Timestep, and so on. Separation of Concerns At first, the existence of a TimeStep in this pattern may seem unnecessary. Why not simply perform all functions of the TimeStep within a queue event? The answer is that TimeStep s and queue events are kept as separate entities to maintain separation of concerns . Each has its own concerns: TimeStep Record the current state of the simulation and affect changes in the Campaign 's various components ( Extents , BurnMatrices , Cells , etc.) Perform calculations and make decisions about what should happen in the future, and records those decisions in the queue Create snapshots of the Campaign's state at a given time that can be serialized, sent, and used in a client application EventQueueItem Store information about what should happen in the future For example, an item \\(I\\) sitting in the queue determines that at time \\(t_x\\) , Cells \\(A\\) , \\(B\\) , and \\(C\\) should ignite, while Cells \\(D\\) , \\(E\\) , and \\(F\\) should burn out, and Cells \\(G\\) and \\(H\\) should be supressed. However it is not until a TimeStep \\(T\\) is generated and retrieves \\(I\\) from the queue, that the program iterates over the specified Cells, and changes their state within their respective BurnMatrix . While iterating over a Cell , \\(T\\) will determine what should happen to that Cell's neighbors, and generate new items to add to the queue, if any.","title":"Priority Queue"},{"location":"algorithm/queue/queue/#events","text":"The event queue is composed of EventQueueItem s. Each EventQueueItem provides information about some future event. An EventQueueItem takes this shape: interface EventQueueItem { time : number ; setToBurning ?: { [ key : string ] : Cell ; }; setToBurnedOut ?: { [ key : string ] : Cell ; }; } Detailed information can be found in the codebase for each entry.","title":"Events"},{"location":"algorithm/queue/queue/#event-creation","text":"The events in the event queue have an asymetrical, one-to-one relationship with TimeStep s. When a Campaign initializes, an initlal event is pushed into the queue, and then a first TimeStep is initialized. Within the constructor of a TimeStep , it looks for the first event in the queue, and if it finds one, it performs its function based on the next queue event. For every event in the queue, a TimeStep will be created. In turn, a TimeStep may spawn more events to be added to the queue. A TimeStep may spawn multiple events to be added, or none at all. An event in the queue, noted by e above, fuels the creation of a TimeStep , which in turn spawns more events to be added to the queue.","title":"Event creation"},{"location":"algorithm/queue/queue/#timestep-queue-timestep","text":"When a TimeStep grabs the next item out of the queue, that item is removed from the queue (though for debugging purposes, it is moved to PriorityQueue.history ). A TimeStep always ends with a new one being created. The next TimeStep is always processing the next event in the queue, if there is one. And because a TimeStep may spawn new queue events (especially in the first portion of a simulation), the simulation runs in a continuous fashion. TimeSteps spawn more events, which provide the information required in the next Timestep, and so on.","title":"TimeStep \u2192 Queue \u2192 TimeStep"},{"location":"algorithm/queue/queue/#separation-of-concerns","text":"At first, the existence of a TimeStep in this pattern may seem unnecessary. Why not simply perform all functions of the TimeStep within a queue event? The answer is that TimeStep s and queue events are kept as separate entities to maintain separation of concerns . Each has its own concerns:","title":"Separation of Concerns"},{"location":"algorithm/queue/queue/#timestep","text":"Record the current state of the simulation and affect changes in the Campaign 's various components ( Extents , BurnMatrices , Cells , etc.) Perform calculations and make decisions about what should happen in the future, and records those decisions in the queue Create snapshots of the Campaign's state at a given time that can be serialized, sent, and used in a client application","title":"TimeStep"},{"location":"algorithm/queue/queue/#eventqueueitem","text":"Store information about what should happen in the future For example, an item \\(I\\) sitting in the queue determines that at time \\(t_x\\) , Cells \\(A\\) , \\(B\\) , and \\(C\\) should ignite, while Cells \\(D\\) , \\(E\\) , and \\(F\\) should burn out, and Cells \\(G\\) and \\(H\\) should be supressed. However it is not until a TimeStep \\(T\\) is generated and retrieves \\(I\\) from the queue, that the program iterates over the specified Cells, and changes their state within their respective BurnMatrix . While iterating over a Cell , \\(T\\) will determine what should happen to that Cell's neighbors, and generate new items to add to the queue, if any.","title":"EventQueueItem"}]}