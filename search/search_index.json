{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Firestarter.io - Algorithm Documentation About These documents give a general description of the core fire-prediction algorithm that lies at the heart of firestarter. Philosophy","title":"About"},{"location":"#firestarterio-algorithm-documentation","text":"","title":"Firestarter.io - Algorithm Documentation"},{"location":"#about","text":"These documents give a general description of the core fire-prediction algorithm that lies at the heart of firestarter.","title":"About"},{"location":"#philosophy","text":"","title":"Philosophy"},{"location":"algorithm/burnmatrix/","text":"BurnMatrix Creation A BurnMatrix belongs to an Extent . It is a mathematical abstraction representing all the pixels in an extent. A BurnExtent is a Mathjs sparse matrix whose size is the same as the size of the Extent . For example, an Extent that is 3 tiles wide by 2 tiles tall, with a tilesize of 256 pixels, will have a BurnMatrix of size [256 * 3, 256 * 2] . A BurnMatrix is created and associated with an extent when a new Extent is created. The Extent is also available from the BurnMatrix - there is always a 1 to 1 relationship, meaning Extents won't share a BurnMatrix , and vice versa. Coordinates A Mathjs matrix is a wrapped around a javascript array. A 2 dimensional matrix is an array of inner arrays: const matrix = math.zeros(2, 3) [ [0, 0, 0], [0, 0, 0] ]; Note that the coordinates for all matrix operations are in [y, x] format . A BurnMatrix redefines any necessary matrix methods to use [x, y] coordinates for consistency with canvas data methods. For example, CanvasRenderingContext2D.getImageData() takes coordinates in [x, y] order. This is the reason that certain BurnMatrix and Extent methods use [y, x] coordinates.","title":"BurnMatrix"},{"location":"algorithm/burnmatrix/#burnmatrix","text":"","title":"BurnMatrix"},{"location":"algorithm/burnmatrix/#creation","text":"A BurnMatrix belongs to an Extent . It is a mathematical abstraction representing all the pixels in an extent. A BurnExtent is a Mathjs sparse matrix whose size is the same as the size of the Extent . For example, an Extent that is 3 tiles wide by 2 tiles tall, with a tilesize of 256 pixels, will have a BurnMatrix of size [256 * 3, 256 * 2] . A BurnMatrix is created and associated with an extent when a new Extent is created. The Extent is also available from the BurnMatrix - there is always a 1 to 1 relationship, meaning Extents won't share a BurnMatrix , and vice versa.","title":"Creation"},{"location":"algorithm/burnmatrix/#coordinates","text":"A Mathjs matrix is a wrapped around a javascript array. A 2 dimensional matrix is an array of inner arrays: const matrix = math.zeros(2, 3) [ [0, 0, 0], [0, 0, 0] ]; Note that the coordinates for all matrix operations are in [y, x] format . A BurnMatrix redefines any necessary matrix methods to use [x, y] coordinates for consistency with canvas data methods. For example, CanvasRenderingContext2D.getImageData() takes coordinates in [x, y] order. This is the reason that certain BurnMatrix and Extent methods use [y, x] coordinates.","title":"Coordinates"},{"location":"algorithm/campaign/","text":"Campaign Creation A Campaign represents a complete simulation in Firestarter. Given a set of user inputs, a new Campaign is created and its timeline begins running. A Campaign contains the following main sub-elements Campaign.extents - Array of Extent objects Campaign.timesteps - Array of Timestep objects Flow","title":"Campaign"},{"location":"algorithm/campaign/#campaign","text":"","title":"Campaign"},{"location":"algorithm/campaign/#creation","text":"A Campaign represents a complete simulation in Firestarter. Given a set of user inputs, a new Campaign is created and its timeline begins running. A Campaign contains the following main sub-elements Campaign.extents - Array of Extent objects Campaign.timesteps - Array of Timestep objects","title":"Creation"},{"location":"algorithm/campaign/#flow","text":"","title":"Flow"},{"location":"algorithm/data/","text":"Data This section discusses data specific to the fire prediction algorithm (as opposed to Firestarter's app database which holds data about user accounts, campaigns, etc). Data Types Firestarter requires a myriad of GIS data, readily available via web sources for the areas where simulations are being run. The subject content of data can generally be divided into two classes: environmental data, and human-oriented data. Here are a few examples of each: Environmental Data Types Topography (elevation, slope, aspect) Ground Cover Weather (wind, temperature, humidity) Human Oriented Data Real estate data Fire supression capabiity Census bureau data How data is retrieved depends on the type of data and available sources. Data must be available for any given point on the map in a given map extent. For a given point, different data types will be available in different formats, generally falling into one of the two following types: Scalar : A singular numerical value. For example, elevation is numerical value in meters Vector : A value with magnitude and direction. For example, wind has both speed and direction, or topography has both slope (magnitued) and aspet (direction)","title":"Data"},{"location":"algorithm/data/#data","text":"This section discusses data specific to the fire prediction algorithm (as opposed to Firestarter's app database which holds data about user accounts, campaigns, etc).","title":"Data"},{"location":"algorithm/data/#data-types","text":"Firestarter requires a myriad of GIS data, readily available via web sources for the areas where simulations are being run. The subject content of data can generally be divided into two classes: environmental data, and human-oriented data. Here are a few examples of each: Environmental Data Types Topography (elevation, slope, aspect) Ground Cover Weather (wind, temperature, humidity) Human Oriented Data Real estate data Fire supression capabiity Census bureau data How data is retrieved depends on the type of data and available sources. Data must be available for any given point on the map in a given map extent. For a given point, different data types will be available in different formats, generally falling into one of the two following types: Scalar : A singular numerical value. For example, elevation is numerical value in meters Vector : A value with magnitude and direction. For example, wind has both speed and direction, or topography has both slope (magnitued) and aspet (direction)","title":"Data Types"},{"location":"algorithm/overview/","text":"Overview","title":"Overview"},{"location":"algorithm/overview/#overview","text":"","title":"Overview"},{"location":"algorithm/cell/cell/","text":"Cell A Cell represents a single pixel within a BurnMatrix . At its core, it is convenience class for interacting with and making changes to the BurnMatrix . A Cell is tied to a particular Extent , and it has methods which enable it to access the Extent 's data at its own position within that Extent . It is also connected to the Extent 's BurnMatrix , and is able to get and set burn values at the Cell 's position in its BurnMatrix . FireStarter's stochastic model relies on a Cell 's ability to access its neighboring positions within its BurnMatrix . To that end, a Cell has the neighbors() method, which spawns 8 NeighborCell s, forming a Moore Neighborhood . NeighborCell When a Cell calls its neighbors() method, an array of 8 NeighborCells is returned, representing the 8 pixels that surround the original cell. Each NeighborCell has additional properties used to calculate the probability of whether or not fire will spread from a burning Cell to that NeighborCell . For example, the terrain slope from the origin cell to each neighbor is produced when calling NeighborCell.getSlopeFromOriginCell . Similarly the wind component in the direction of that NeighborCell is available by calling `NeighborCell.getWindComponent . In this way, the burn status of each pixel in a BurnMatrix is determined by each Neighborcell . A Campaign always begins with a TimeStep in which a single Cell being set to burning . In the following TimeStep , the burn status of each NeighborCell is determined, and all burning Cell s are kept track of by the BurnMatrix . In the proceeding TimeStep s, all burning cells are iterated over, each burning Cell spawns its NeighborCells , whose burn statuses are determined and recorded, and so forth.","title":"Cell"},{"location":"algorithm/cell/cell/#cell","text":"A Cell represents a single pixel within a BurnMatrix . At its core, it is convenience class for interacting with and making changes to the BurnMatrix . A Cell is tied to a particular Extent , and it has methods which enable it to access the Extent 's data at its own position within that Extent . It is also connected to the Extent 's BurnMatrix , and is able to get and set burn values at the Cell 's position in its BurnMatrix . FireStarter's stochastic model relies on a Cell 's ability to access its neighboring positions within its BurnMatrix . To that end, a Cell has the neighbors() method, which spawns 8 NeighborCell s, forming a Moore Neighborhood .","title":"Cell"},{"location":"algorithm/cell/cell/#neighborcell","text":"When a Cell calls its neighbors() method, an array of 8 NeighborCells is returned, representing the 8 pixels that surround the original cell. Each NeighborCell has additional properties used to calculate the probability of whether or not fire will spread from a burning Cell to that NeighborCell . For example, the terrain slope from the origin cell to each neighbor is produced when calling NeighborCell.getSlopeFromOriginCell . Similarly the wind component in the direction of that NeighborCell is available by calling `NeighborCell.getWindComponent . In this way, the burn status of each pixel in a BurnMatrix is determined by each Neighborcell . A Campaign always begins with a TimeStep in which a single Cell being set to burning . In the following TimeStep , the burn status of each NeighborCell is determined, and all burning Cell s are kept track of by the BurnMatrix . In the proceeding TimeStep s, all burning cells are iterated over, each burning Cell spawns its NeighborCells , whose burn statuses are determined and recorded, and so forth.","title":"NeighborCell"},{"location":"algorithm/extent/extent/","text":"Extent Creation An Extent represents a map extent. It is created from a L.LatLngBounds : const extent = new Extent((bounds: L.LatLngBounds)); A new Extent takes in a bounds object, and refits those bounds to the bounds of the tiles that fit inside it from a standard Web Mercator Tile Layer: On extent creation, the tiles that fit within that extent are listed using xyz-affair : The extent's bounds are set as the bounds of the tiles that fit in the L.LatLngBounds fed to new Extent : Data fetching Once created, extent.fetchData() can be called, which will fetch all data sources for the extent. Growing an Extent In an effort to download data on a \"need-to-have\" basis, an Extent starts with a default size. In each TimeStep , the algorithm assigns Cell s within an Extent 's BurnMatrix to have non-zero burn values. At the time of that assignment, the distance of the Cell from the edges of its Extent is checked, and if that distance falls below the config's threshold, the Extent expands . Depending on which edge the Cell is closest to, Extent will call expandUp , expandDown , expandRight , or expandLeft . These methods will expand the Extent 's bounds and fetch all data tiles for the newly expanded parts of the Extent . expandUp and expandLeft will also reset the origin of the index and reset all the positions of the Cell s associated with the Extent . When an Extent grows by calling any of the above methods, it must be checked against all other Extent s in the Campaign for potential overlap.","title":"Extent"},{"location":"algorithm/extent/extent/#extent","text":"","title":"Extent"},{"location":"algorithm/extent/extent/#creation","text":"An Extent represents a map extent. It is created from a L.LatLngBounds : const extent = new Extent((bounds: L.LatLngBounds)); A new Extent takes in a bounds object, and refits those bounds to the bounds of the tiles that fit inside it from a standard Web Mercator Tile Layer: On extent creation, the tiles that fit within that extent are listed using xyz-affair : The extent's bounds are set as the bounds of the tiles that fit in the L.LatLngBounds fed to new Extent :","title":"Creation"},{"location":"algorithm/extent/extent/#data-fetching","text":"Once created, extent.fetchData() can be called, which will fetch all data sources for the extent.","title":"Data fetching"},{"location":"algorithm/extent/extent/#growing-an-extent","text":"In an effort to download data on a \"need-to-have\" basis, an Extent starts with a default size. In each TimeStep , the algorithm assigns Cell s within an Extent 's BurnMatrix to have non-zero burn values. At the time of that assignment, the distance of the Cell from the edges of its Extent is checked, and if that distance falls below the config's threshold, the Extent expands . Depending on which edge the Cell is closest to, Extent will call expandUp , expandDown , expandRight , or expandLeft . These methods will expand the Extent 's bounds and fetch all data tiles for the newly expanded parts of the Extent . expandUp and expandLeft will also reset the origin of the index and reset all the positions of the Cell s associated with the Extent . When an Extent grows by calling any of the above methods, it must be checked against all other Extent s in the Campaign for potential overlap.","title":"Growing an Extent"}]}